------------------------- experiments ---------------------------------------------------------------------------------------------

equ : (Moore (List A) B) â‰… (Moore (Listâº A) B)
equ = record {
    to = moore-listâº-inclusion
  ; from = moore-listâº-ext
  ; toâˆ˜from=1 = Î» { record { E = E ; d = d ; s = s } â†’ {!   !}  }
  ; fromâˆ˜to=1 = Î» { record { E = E ; d = d ; s = s } â†’ {!   !} }
  }

-- if Ji -| moorify', then Pâˆ _ â‹‰ â‰… KL:
-- Ji x -> y
-- ix -> ğ•ƒy
-- x -> KLy => KL â‰… L'

  {-
  ğ•âŠ£ğ•ƒ' : (M : Moore A B) â†’ (N : Mealy A B) â†’  (Mealyâ‡’ N ({!   !} M)) â‰… (Mooreâ‡’ (moorify N) M)
  ğ•âŠ£ğ•ƒ' M N = let module M = Moore M
                 module N = Mealy N in record
    { to = Î» Î± â†’ let module Î± = Mealyâ‡’ Î± in record
      { hom  = Î» { m â†’ {!   !} } -- Î±.hom x , M.s x
      ; d-eq = Î» { g â†’ {!   !} } --(a , e) â†’ congâ‚‚ _,_ (Î±.d-eq _) {! sym (Î±.s-eq (a , e))  !} } --Î» {(a , e) â†’ congâ‚‚ _,_ (Î±.d-eq (a , e)) (sym (Î±.s-eq (a , e)))}
      ; s-eq = {!   !} --Î» x â†’ refl
      }
    ; from = Î» Î² â†’ let module Î² = Mooreâ‡’ Î² in record
      { hom  = Î» n â†’ {!   !} --projâ‚ âˆ˜ Î².hom --Î» x â†’ projâ‚ (Î².hom x)
      ; d-eq = {!   !} --Î» {(a , e) â†’ cong projâ‚ (Î².d-eq (a , e))}
      ; s-eq = {!   !} --Î» {(a , e) â†’ trans (sym (cong projâ‚‚ (Î².d-eq (a , e)))) (Î².s-eq (Î².X.d (a , e)))}
      }
    ; toâˆ˜from=1 = Î» x â†’ let module x = Mooreâ‡’ x
                         in Mooreâ‡’-â‰¡ _ x {!   !} --Î» x â†’ let module x = Mooreâ‡’ x
                    --        in Mooreâ‡’-â‰¡ _ x (extensionality (Î» t â†’ sym (cong (Î» b â†’ projâ‚ (x.hom t) , b) (x.s-eq t))))
    ; fromâˆ˜to=1 = Î» x â†’ Mealyâ‡’-â‰¡ _ x {!   !}
    }
    -}

{-
mealify-advanceâ‚‚âŠ£ğ•ƒÂ² : (M : Moore A B) â†’ (N : Mealy A B) â†’ (Mealyâ‡’ (mealify-advanceâ‚‚ M) N) â‰… (Mooreâ‡’ M (Queue â‹ˆ (moorify N)))
mealify-advanceâ‚‚âŠ£ğ•ƒÂ² M N = let module M = Moore M
                              module N = Mealy N in
  record { to = Î» Î± â†’ let module Î± = Mealyâ‡’ Î± in
            record { hom = Î» {x â†’ ({! Î±.hom   !} , {!   !}) , {!   !}}
                   ; d-eq = Î» {(a , e) â†’ {!  Î±.s-eq (a , e) !}}
                   ; s-eq = Î» x â†’ refl }
         ; from = Î» Î² â†’ let module Î² = Mooreâ‡’ Î² in
            record { hom = Î» x â†’ {!   !}
                   ; d-eq = Î» {(a , e) â†’ {!   !}}
                   ; s-eq = Î» {(a , e) â†’ {!   !}} }
         ; toâˆ˜from=1 = Î» x â†’ let module x = Mooreâ‡’ x in Mooreâ‡’-â‰¡ _ x {!   !}
         ; fromâˆ˜to=1 = Î» x â†’ Mealyâ‡’-â‰¡ _ x {!   !}
         }

-- can't commute: the number of times one applies moorify must be the same.
-- but:

morphism? : (M : Mealy A B) â†’ Mooreâ‡’ ((moorify âˆ˜ moore-ext âˆ˜ moorify) M)
                                      ((moore-listâº-ext âˆ˜ moorify âˆ˜ mealy-ext) M)
morphism? M = record
  { hom = Î» {((e , b) , b') â†’ e , b'}
  ; d-eq = Î» {(e , (e' , b) , b') â†’ congâ‚‚ _,_ {!   !} {!   !}}
  ; s-eq = Î» {((e , b') , b) â†’ refl}
  }

quadrato : âˆ€ {M : Moore A B} â†’ Mealy[ toList , id ] (moore-ext M) â‰¡ mealy-ext (mealify-advance M)
quadrato {M = record { E = E ; d = d ; s = s }} = {!   !}

morphism2? : (M : Moore A B) â†’ Mealyâ‡’ (eğ• M) (ğ•ğ•ƒe M)
morphism2? M = let module M = Moore M in record
  { hom = Î» x â†’ x , M.s x
  ; d-eq = Î» {(a âˆ· [] , e) â†’ refl
            ; (a âˆ· x âˆ· as , e) â†’ {!   !} } --congâ‚‚ _,_ (cong (Î» t â†’ M.d (a , t)) (cong (Î» p â†’ M.d (x , p)) {!   !})) (cong (Î» t â†’ M.s (M.d (a , t))) {!   !})}
  ; s-eq = Î» {(a âˆ· as , e) â†’ {!   !}}
  }

  mealify-advanceâ‚™ : â„• â†’ Moore A B â†’ Mealy A B
  mealify-advanceâ‚™ {A} {B} n M = record
    { E = Vec B n Ã— M.E
    ; d = Î» { (a , f) â†’ {!   !} }
    ; s = Î» { (a , g) â†’ M.s {!   !} }
    } where module M = Moore M
            d = flip (curry M.d)

  aggiunzia-divina : âˆ€ {n}
    â†’ (Mealyâ‡’ (mealify-advanceâ‚™ n Mre) Mly) â‰… (Mooreâ‡’ Mre (Queueâ‚™ n â‹‰ Mly))
  aggiunzia-divina {Mre = Mre} {Mly = Mly} = record
      { to = Î» Î± â†’ let module Î± = Mealyâ‡’ Î± in record
        { hom = Î» x â†’ Î±.hom (replicate (Mre.s x) , x) , replicate (Mre.s x) --Î±.hom {! Mly.s  !} , replicate (Mre.s x) --Î» s â†’ (Î±.hom (s , {!   !})) , replicate (Mre.s s)
        ; d-eq = {!   !}
        ; s-eq = {!   !}
        }
      ; from = Î» Î± â†’ let module Î± = Mooreâ‡’ Î± in record
        { hom = Î» f â†’ projâ‚ (Î±.hom (projâ‚‚ f)) --projâ‚ (Î±.hom {! Mre.s  !}) --projâ‚ (Î±.hom (f {! Mre.s  !})) --Î» { (s , v) â†’ projâ‚ (Î±.hom s) }
        ; d-eq = {!   !}
        ; s-eq = {!   !}
        }
      ; toâˆ˜from=1 = Î» x â†’ let module x = Mooreâ‡’ x in
          Mooreâ‡’-â‰¡ _ x (extensionality Î» x â†’ {! x.s-eq x  !})
      ; fromâˆ˜to=1 = Î» x â†’ let module x = Mealyâ‡’ x in
          Mealyâ‡’-â‰¡ _ x ((extensionality Î» x â†’ {! x.d-eq  !}))
      }
    where module Mre = Moore Mre
          module Mly = Mealy Mly

  aggiunzia-divina-reverse : âˆ€ {n}
    â†’ (Mealyâ‡’ Mly (mealify-advanceâ‚™ n Mre)) â‰… (Mooreâ‡’ (Queueâ‚™ n â‹‰ Mly) Mre)
  aggiunzia-divina-reverse {Mly = Mly} {Mre = Mre} = record
      { to = Î» Î± â†’ let module Î± = Mealyâ‡’ Î± in record
        { hom = {!   !} --Î» { (s , x âˆ· v) â†’ {! Î±.hom  !} } --Î±.hom s {! Mre.s  !} } -- Î» s â†’ (Î±.hom (s , {!   !})) , replicate (Mre.s s)
        ; d-eq = {!   !}
        ; s-eq = {!   !}
        }
      ; from = Î» Î± â†’ let module Î± = Mooreâ‡’ Î± in record
        { hom = Î» x â†’ {!   !} --replicate (Î±.hom (x , {! Mre.s  !})) --Î» v â†’ Î±.hom (x , {! Mre.s  !}) --Î±.hom (x , replicate (Mre.s (Mre.d ({! Mly.d  !} , Î±.hom {!   !})))) , {!   !} --Î» { (s , v) â†’ projâ‚ (Î±.hom s) }
        ; d-eq = {!   !}
        ; s-eq = {!   !}
        }
      ; toâˆ˜from=1 = Î» x â†’ let module x = Mooreâ‡’ x in
          Mooreâ‡’-â‰¡ _ x (extensionality Î» x â†’ {! x.d-eq ?  !})
      ; fromâˆ˜to=1 = {!   !}
      }
    where module Mre = Moore Mre
          module Mly = Mealy Mly
-}
